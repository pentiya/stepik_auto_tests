3.2 Тестирование web-приложений и тестовые фреймворки

Тестирование web-приложений и тестовые фреймворки
Далее мы рассмотрим, как использовать Selenium Webdriver для написания автоматических тестов. Почему мы еще не можем назвать тестами скрипты, которые мы писали в предыдущих модулях?

Для этого нам придётся познакомиться с тестовыми фреймворками unittest и PyTest, которые позволяют создавать легко читаемые проверки ожидаемых результатов в тестах, удобно настраивать запуск большого количества тестов в нужных окружениях, организовывать хранение тестов и генерацию отчётов для последующего анализа.

В качестве основы для данного урока мы адаптировали руководство про написание юнит-тестов в Python:

https://realpython.com/python-testing/

Содержание урока
Автоматизированное и ручное тестирование
Юнит-тесты и интеграционные тесты
Задание: пирамида тестирования
Структура теста
Проверка ожидаемого результата
Составные сообщения об ошибках 
Задание: составные сообщения об ошибках
Задание: составные сообщения об ошибках и поиск подстроки
Тестовый сценарий
Выбор test runner
unittest
Задание: оформляем тесты в стиле unittest 


Автоматизированное и ручное тестирование
Чтобы начать писать хорошие автотесты, нужно ﻿разобраться, в чем плюсы и минусы ручного и автоматизированного тестирования.

Ручные тесты	                                                                    Автотесты

Шаги могут быть описаны достаточно абстрактно,                     Строгий порядок шагов и их чёткая детализация.       
поэтому тестировщик может увидеть новые проблемы,                  Проверяют только то, что было заложено изначально    
следуя сценарию теста.                                             в сценарий теста, поэтому могут быть пропущены       
                                                                   новые ошибки в продукте.                             
В ручном тесте может содержаться шаг 
"Зарегистрировать нового пользователя" без пояснений, 
как это делать, в автотесте должны быть строго 
описаны данные для теста и сценарий регистрации.

- Из-за абстрактности описания шагов ручные тесты 
иногда могут приводить к ложноположительным результатам, 
когда ожидаемый результат достигнут, но в реальности 
тестировщик выполнил сценарий неправильно, пропустив баг. 	+ Запуск автотестов обычно приводит к одним и тем же результатам, 
- Требуется много времени для проверки регрессии,                 т.к. сценарий описан точно.
что приводит к усталости тестировщика и ошибкам 
в проверках из-за человеческого фактора 
(человеку сложно долго выполнять монотонную работу).	        + Можно запускать на каждый коммит в тестируемом приложении, 
                                                                  что позволяет раньше обнаруживать ошибки в продукте.


Отдельно стоит описать отрицательные стороны автоматизированного тестирования:

возможная нестабильность теста, которая не связана с качеством самого теста, 
а вызывается внешними проблемами: нестабильное сетевое соединение, 
проблемы с серверами, обновление кода продукта в момент запуска тестов;
требуется достаточно много времени на разработку и поддержку набора автотестов.

Несмотря на наличие минусов автотестов, в большинстве случаев их использование 
на проекте помогает быстрее находить ошибки в коде приложения и поддерживать 
качество продукта на достаточном уровне. Автотесты помогают отделу тестирования 
оптимизировать свою работу, чтобы сделать счастливее пользователей, которые 
быстрее получают новые фичи и меньше страдают от ошибок в продукте, так как 
разработчики раньше узнают о багах и могут заранее принять меры для их устранения, 
не откладывая релиз продукта. Таким образом, благодаря автотестам налаживается бизнес, 
который может увеличить скорость внедрения фич, приносящих прибыль.

Ручные тесты в идеальном случае остаются только на этапе проверки новых фич и в виде 
исследовательского тестирования, которое позволяет найти проблемы в сложных пользовательских сценариях.

Юнит-тесты и интеграционные тесты
========================================
Если вы работаете в тестировании, то уже знаете разницу между юнит-тестами 
и интеграционными тестами. Юнит-тесты проверяют очень маленький кусок кода, 
обычно конкретную функцию, и чаще всего их пишут разработчики, которые хорошо 
понимают возможные крайние случаи для своего стека технологий. Интеграционные 
тесты проверяют взаимодействие сразу нескольких систем. Они могут создаваться 
и поддерживаться как разработчиками и тестировщиками, так и аналитиками 
(если для них разработан удобный фреймворк для написания тестов).

Юнит-тесты всегда автоматизированы, так как проверяют непосредственно работу кода. 
Интеграционные тесты могут быть ручными и автоматизированными. 
Иногда выделяют отдельную категорию end-to-end (е2е) тестов, которые проверяют 
полный стек технологий приложения и пользовательский сценарий взаимодействия 
с приложением как с черным ящиком. Если говорить про UI-тесты, которые разрабатываются 
с помощью Selenium, то их стоит отнести к разряду end-to-end тестов, так как 
они проверяют совместную работу всех систем web-продукта: работу frontend и backend, 
работу базы данных, дополнительные сервисы, такие как аналитика, платежные системы и так далее. 

Подробно про разные типы автотестов мы говорить не будем, но советуем вам изучить теорию самостоятельно. 
Вот, например, отличная и подробная статья: Пирамида тестов на практике.
https://habr.com/ru/post/358950/

Структура теста
=========================
Для написания UI-тестов можно использовать те же возможности Python, 
что и для написания юнит-тестов, которые создаются разработчиками. 

Любой тест должен содержать:
---------------------------
Входные данные.
Тестовый сценарий, то есть набор шагов, которые надо выполнить для получения результата.
Проверка ожидаемого результата.

Давайте обсудим, как именно можно производить проверки. 

Проверка ожидаемого результата
---------------------------------
Как можно проверить ожидаемый результат? Для этого используется встроенная в Python 
инструкция assert, которая проверяет истинность утверждений. assert True не приводит 
к выводу дополнительных сообщений, а вот assert False вызовет исключение AssertionError.

Рассмотрим работу assert на примере встроенной функции abs(), которая возвращает 
абсолютное значение числа по модулю. Для этого активируйте созданное ранее виртуальное 
окружение и запустите интерпретатор Python. Например, для Linux выполните:

source selenium_env/bin/activate
python

Теперь будем вводить приведенные ниже команды и смотреть на результат их выполнения.

Если значение выражения истинно, то в консоли не должно появиться дополнительных сообщений. Выполним:

>>> assert abs(-42) == 42

Если условие не выполнено, то в консоли выводится лог ошибки с названием файла и номером строчки, 
в которой произошла ошибка, а также тип ошибки AssertionError:

>>> assert abs(-42) == -42
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
AssertionError

Простое сообщение AssertionError не очень информативно. Когда тестов становится много, 
бывает сложно вспомнить, что именно мы проверяем в данном тесте. Для добавления дополнительного 
сообщения можно при вызове assert через запятую написать нужное сообщение, которое будет выведено 
в случае ошибки проверки результата:

>>> assert abs(-42) == -42, "Should be absolute value of a number"
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
AssertionError: Should be absolute value of a number

Составные сообщения об ошибках 
=====================================
Отдельно хочется поговорить про качество сообщений об ошибках, которые показываются при падении теста. 
Почему это важно? Хорошо написанный текст помогает быстро локализовать найденный баг и разобраться в том, 
что произошло и из-за чего тест упал. Хороший assert сэкономит вам часы вашей работы, особенно когда 
количество тестов переходит за сотню.

В целом, тут как с любым фидбеком: важно давать его точно и актуально. Если вы проверяете наличие элемента, 
то обязательно пишите, что это за элемент по смыслу на странице: 

assert self.is_element_present('create_class_button', timeout=30), "No create class button"

Примечание: Функция is_element_present() вспомогательная. 
Как её реализовать и использовать, мы разберемся чуть позжe.

Если элемент встречается на нескольких страницах приложения, 
не лишним будет указать, где именно произошла ошибка: 

assert self.is_element_present('new_announcement_button', timeout=30), "No new announcement button on profile page"

Если вы работаете с каким-то текстом (например, проверяете информационное сообщение, текущий url, 
ссылку, placeholder в input-элементе или любой другой текст), в сообщении об ошибке всегда лучше 
выводить оба значения: то, которое ожидалось, и то, которое получили по факту. 
Всё как в хорошем багрепорте: ожидаемый и фактический результат.

Форматирование строк с помощью конкатенации
==============================================
В питоне такое можно провернуть с помощью конкатенации строк, например:

actual_result = "abrakadabra"
print("Wrong text, got " + actual_result + ", something wrong")

Но из-за обилия кавычек, знаков сложения и вот этого всего этот способ не самый удобный и читается тоже плохо.

Форматирование строк с помощью str.format
---------------------------------------------
Гораздо лучше воспользоваться возможностью python для форматирования строк. 
Дополнительно можно почитать здесь: 
https://realpython.com/python-string-formatting/#2-new-style-string-formatting-strformat

Если вкратце, то python умеет подставлять пользовательские значения в строки с помощью 
функции .format(). Синтаксис выглядит примерно так:

"Let's count together: {}, then goes {}, and then {}".format("one", "two", "three")

Попробуйте запустить её в интерпретаторе:

print("Let's count together: {}, then goes {}, and then {}".format("one", "two", "three"))

Такая строка при исполнении кода превратится в: 

Let's count together: one, then goes two, and then three

Таким образом мы можем удобно компоновать ожидаемое и фактическое значение в одну строку.

Форматирование строк с помощью f-strings
----------------------------------------------
И наконец наиболее современный способ форматирования строк, который появился в Python3.6, 
носит название f-strings. Он позволяет исполнять выражения на Python прямо внутри строк, 
обладает еще большей лаконичностью и удобством использования. Для использования возможностей 
f-strings нужно указывать символ f перед строкой в таком формате: f"ваша строка {my_var}". 
В фигурных скобках указывается имя переменной, значение которой надо подставить в строку, 
или выражение, результат исполнения которого также требуется подставить в вашу строку.

Подробнее про f-strings можно почитать здесь: 
https://realpython.com/python-string-formatting/#3-string-interpolation-f-strings-python-36. 
Так как мы предполагаем, что вы используете последнюю версию Python, 
то предлагаем вам применять именно этот подход в данном курсе.

Пример 1:

str1 = "one"
str2 = "two"
str3 = "three"
print(f"Let's count together: {str1}, then goes {str2}, and then {str3}")

Итог выполнения выражений в интерпретаторе:

Let's count together: one, then goes two, and then three

Пример 2:

actual_result = "abrakadabra"
f"Wrong text, got {actual_result}, something wrong"

Итог выполнения выражений в интерпретаторе:

Wrong text, got abrakadabra, something wrong

Пример 3:

>>> f"{2+3}"
'5'
 

Еще один важный момент: 
когда вы работаете с текстом элементов на странице или любым другим контентом, 
который может измениться, всегда записывайте его в отдельную переменную для сравнения. 

неправильно: 

assert self.catalog_link.text  == "Каталог", \
    f"Wrong language, got {self.catalog_link.text} instead of 'Каталог'" 

Дважды считывать атрибут — это плохая практика, потому что при повторном считывании 
текст на странице может измениться, и вы получите неактуальный текст об ошибке. 
Результат выполнения такого теста сложно анализировать: 

"Wrong language, got 'Каталог' instead of 'Каталог'"

правильно: 

catalog_text = self.catalog_link.text # считываем текст и записываем его в переменную
assert catalog_text == "Каталог", \
    f"Wrong language, got {catalog_text} instead of 'Каталог'"  


Тестовые сценарии
=========================
Созданные тесты нужно сохранить в файле, чтобы его было удобно запускать 
и хранить в системе контроля версий. 
Давайте создадим файл test_abs_project.py и напишем в нём следующий код:

def test_abs1():
    assert abs(-42) == 42, "Should be absolute value of a number" 

if __name__ == "__main__":
    test_abs1()
    print("All tests passed!")

Мы поместили тестовый сценарий в функцию для разделения тест-кейсов 
и возможности их независимого запуска.

Не вдаваясь в подробности, скажем только, что конструкция if __name__ == "__main__" 
служит для подтверждения того, что данный скрипт был запущен напрямую, 
а не вызван внутри другого файла в качестве модуля. Весь код написанный в теле 
этого условия будет выполнен только если пользователь запустил файл самостоятельно. 
Подробнее можно ознакомиться в видео Олега Молчанова. 
https://www.youtube.com/watch?v=cW_-zGG4ef4

В этой конструкции мы вызвали функцию test_abs1(), которая выполняет тестовый сценарий.

С помощью print("All tests passed!") мы вывели сообщение, если все тесты прошли успешно.

Чтобы запустить тест, выполните в консоли команду:

python test_abs_project.py

Вы должны увидеть в консоли сообщение "All tests passed!".

Если нам нужно добавить еще один тест, мы можем написать его как функцию в этом же файле. 
В приведенном примере мы уже не увидим сообщение "Everything passed", 
так как падение любого теста вызывает выход из программы:

def test_abs1():
    assert abs(-42) == 42, "Should be absolute value of a number"

def test_abs2():
    assert abs(-42) == -42, "Should be absolute value of a number"

if __name__ == "__main__":
    test_abs1()
    test_abs2()
    print("Everything passed")

Запустите файл снова. Вы должны увидеть сообщение об упавшем втором тесте:

$ python test_abs_project.py
Traceback (most recent call last):
  File "test_abs_project.py", line 9, in <module>
    test_abs2()
  File "test_abs_project.py", line 5, in test_abs2
    assert abs(-42) == -42, "Should be absolute value of a number"
AssertionError: Should be absolute value of a number

Выбор test runner
========================
В предыдущих шагах мы научились писать простые тесты и запускать их с помощью Python. 
Приведём здесь код тестов и результаты запуска из предыдущего шага еще раз.

test_abs_project.py:

def test_abs1():
    assert abs(-42) == 42, "Should be absolute value of a number"

def test_abs2():
    assert abs(-42) == -42, "Should be absolute value of a number"

if __name__ == "__main__":
    test_abs1()
    test_abs2()
    print("Everything passed")

Консоль:

$ python test_abs_project.py
Traceback (most recent call last):
  File "test_project.py", line 9, in <module>
    test_abs2()
  File "test_project.py", line 5, in test_abs2
    assert abs(-42) == -42, "Should be absolute value of a number"
AssertionError: Should be absolute value of a number

Рассмотрим минусы такого подхода к запуску автотестов:

Когда тестов становится много, сложно становится запускать только тесты из нужных тест-сьютов.

Для каждого теста нужно создавать тестовые данные и окружение отдельно. 
Например, если мы захотим для каждого теста запускать браузер, а после завершения теста браузер 
закрывать, то логику работы с браузером придется дублировать в коде каждого теста.
Если один из тестов завершится с ошибкой, например, тест упадёт с ошибкой AssertionError, 
то последующие тесты не запустятся. Мы не узнаем, были ли проблемы в этих тестах, 
пока не починим упавший тест или пока не запустим эти тесты по отдельности.

Для решения этих проблем и упрощения написания и запуска тестов существуют специальные фреймворки, 
которые называются test runners (тест-раннеры). Можно выделить три основных тестовых фреймворка 
для Python: unittest, PyTest и nose. 
Модуль unittest является встроенным инструментом Python — и это его большой плюс. 
PyTest и nose устанавливаются дополнительно, они позволяют получить расширенные возможности 
по сравнению с unittest. Мы кратко рассмотрим, как используется unittest, а затем изучим возможности PyTest, 
который позволяет писать более простой код тестов по сравнению с unittest и гибко настраивать запуск тестов. 
Еще один плюс использования PyTest в том, что для него существует большое количество плагинов, 
которые позволяют решить практически любую проблему, связанную с запуском автотестов.

unittest
====================
Тест-раннеры сами находят тестовые методы в указанных при запуске файлах, но для этого нужно следовать 
общепринятым правилам. Общее правило для всех фреймворков: название тестового метода должно начинаться 
со слова "test_".  Дальше может идти любой текст, который является уникальным названием для теста:

def test_name_for_your_test():

Для unittest существуют собственные дополнительные правила:

Тесты обязательно должны находиться в специальном тестовом классе.
Вместо assert должны использоваться специальные assertion методы.

Давайте теперь изменим наши предыдущие тесты, чтобы их можно было запустить с помощью unittest. 
Для этого нам понадобится выполнить следующие шаги:

Импортировать unittest в файл: import unittest
Создать класс, который должен наследоваться от класса TestCase: class TestAbs(unittest.TestCase):
Превратить тестовые функции в методы, добавив ссылку на экземпляр класса self в качестве первого аргумента функции: def test_abs1(self):
Изменить assert на self.assertEqual()
Заменить строку запуска программы на unittest.main()

import unittest

class TestAbs(unittest.TestCase):
    def test_abs1(self):
        self.assertEqual(abs(-42), 42, "Should be absolute value of a number")
        
    def test_abs2(self):
        self.assertEqual(abs(-42), -42, "Should be absolute value of a number")
        
if __name__ == "__main__":
    unittest.main()

После изменений запустим наш файл с тестами всё так же с помощью Python:

python test_abs_project.py

.F

======================================================================

FAIL: test_abs2 (__main__.TestAbs)

----------------------------------------------------------------------

Traceback (most recent call last):

  File "test_abs_project.py", line 9, in test_abs2

    self.assertEqual(abs(-42), -42, "Should be absolute value of a number")

AssertionError: Should be absolute value of a number

----------------------------------------------------------------------

Ran 2 tests in 0.000s

FAILED (failures=1)
Теперь мы видим более подробную информацию о результатах запуска: было запущено два теста, один тест выполнился с ошибкой. Место ошибки и пояснение к ней отображаются в логе.

В следующем уроке мы рассмотрим преимущества и особенности использования тестового фреймворка PyTest. Если вы хотите использовать unittest ﻿в своих проектах, вы можете изучить документацию самостоятельно.
https://docs.python.org/3/library/unittest.html
