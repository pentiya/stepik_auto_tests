Поиск элементов с помощью Selenium WebDriver
Работа с браузером в Selenium
Задание: поиск элементов с помощью Selenium Webdriver
Задание: поиск элемента по тексту в ссылке
Поиск всех необходимых элементов с помощью find_elements_by
Задание: использование метода find_elements_by
Задание: поиск элемента по XPath
Уникальность селекторов: часть 1
Уникальность селекторов: часть 2
Задание: уникальность селекторов
Уникальность селекторов: часть 3
Итоги модуля


Поиск элементов с помощью Selenium
======================================
Для поиска элементов на странице в Selenium WebDriver используются несколько стратегий, 
позволяющих искать по атрибутам элементов, текстам в ссылках, CSS-селекторам и XPath-селекторам. 
Существуют следующие методы поиска элементов:

find_element_by_id — поиск по уникальному атрибуту id элемента. 
Если ваши разработчики проставляют всем элементам в приложении уникальный id, то вам повезло, 
и вы чаще всего будет использовать этот метод, так как он наиболее стабильный;

find_element_by_css_selector — поиск элемента с помощью правил на основе CSS. 
Это универсальный метод поиска, так как большинство веб-приложений использует CSS для вёрстки 
и задания оформления страницам. Если find_element_by_id вам не подходит из-за отсутствия id у элементов, 
то скорее всего вы будете использовать именно этот метод в ваших тестах;

find_element_by_xpath — поиск с помощью языка запросов XPath, позволяет выполнять очень гибкий поиск элементов;

find_element_by_name — поиск по атрибуту name элемента;

find_element_by_tag_name — поиск элемента по названию тега элемента;

find_element_by_class_name — поиск по значению атрибута class;

find_element_by_link_text — поиск ссылки на странице по полному совпадению;

find_element_by_partial_link_text — поиск ссылки на странице, если текст селектора совпадает с любой частью текста ссылки.

Например, мы хотим найти кнопку со значением id="submit_button":

from selenium import webdriver
browser = webdriver.Chrome()
browser.get("http://suninjuly.github.io/simple_form_find_task.html")
button = browser.find_element_by_id("submit")

Если страница у вас загрузилась, но дальше ничего не происходит, вернитесь обратно в консоль, 
в которой вы запускали ваш скрипт. Скорее всего, вы увидите там ошибку NoSuchElementException. 
Она будет выглядеть следующим образом:

selenium.common.exceptions.NoSuchElementException: Message: no such element: Unable to locate element: {"method":"id","selector":"submit"}

Ошибка очевидна: мы неправильно указали локатор — значит, кнопки с таким id на странице нет.

Исправим локатор, чтобы наш код проходил без ошибок:

from selenium import webdriver
browser = webdriver.Chrome()
browser.get("http://suninjuly.github.io/simple_form_find_task.html")
button = browser.find_element_by_id("submit_button")

Есть второй способ для поиска элементов с помощью универсального метода find_element() 
и полей класса By из библиотеки selenium. Пример:

from selenium import webdriver
from selenium.webdriver.common.by import By
browser = webdriver.Chrome()
browser.get("http://suninjuly.github.io/simple_form_find_task.html")
button = browser.find_element(By.ID, "submit_button")

Можно использовать те же стратегии поиска, что и в первом способе. 
Второй способ более удобен для оформления архитектуры тестовых сценариев с помощью подхода Page Object Model, 
о котором мы будем говорить далее. Пока же предлагаем пользоваться первым методом с явным указанием способа поиска, 
так как он кажется нам более удобным, но ничто не мешает вам пользоваться и тем, и другим. 
Поля класса By, которые можно использовать для поиска:

By.ID – поиск по уникальному атрибуту id элемента;
By.CSS_SELECTOR – поиск элементов с помощью правил на основе CSS;
By.XPATH – поиск элементов с помощью языка запросов XPath;
By.NAME – поиск по атрибуту name элемента;
By.TAG_NAME – поиск по названию тега;
By.CLASS_NAME – поиск по атрибуту class элемента;
By.LINK_TEXT – поиск ссылки с указанным текстом. Текст ссылки должен быть точным совпадением;
By.PARTIAL_LINK_TEXT – поиск ссылки по частичному совпадению текста.

!Важно. Вы можете столкнуться с ситуацией, когда на странице будет несколько элементов, 
подходящих под заданные вами параметры поиска. В этом случае WebDriver вернет вам только первый элемент, 
который встретит во время поиска по HTML. Если вам нужен не первый, а второй или следующие элементы, 
вам нужно либо задать более точный селектор для поиска, либо использовать методы find_elements_by, 
которые мы рассмотрим чуть позже.

Иногда в статьях про Selenium WebDriver вы также будете встречать термин "локаторы", 
под которым подразумеваются стратегии поиска и значения, по которым должен выполняться поиск. 
Например, можно искать по локатору By.ID со значением "send_button".

Работа с браузером в Selenium
======================================
Если вы уже пробовали запускать примеры скриптов, то могли заметить, 
что браузер не всегда закрывается после выполнения кода. Поэтому обратите внимание на то, 
что необходимо явно закрывать окно браузера в нашем коде при помощи команды browser.quit(). 
Каждый раз при открытии браузера browser = webdriver.Chrome() в системе создается процесс, 
который останется висеть, если вы вручную закроете окно браузера. Чтобы не остаться без 
оперативной памяти после запуска нескольких скриптов, всегда добавляйте к своим скриптам команду закрытия:

from selenium import webdriver
from selenium.webdriver.common.by import By
link = "http://suninjuly.github.io/simple_form_find_task.html"
browser = webdriver.Chrome()
browser.get(link)
button = browser.find_element(By.ID, "submit_button")
button.click()
# закрываем браузер после всех манипуляций
browser.quit()

Важно еще пояснить разницу между двумя командами: browser.close() и browser.quit(). 
Какая между ними разница, ведь на первый взгляд обе они осуществляют одно и то же? 

На самом деле, browser.close() закрывает текущее окно браузера. 
Это значит, что если ваш скрипт вызвал всплывающее окно, или открыл что-то в новом окне или вкладке браузера, 
то закроется только текущее окно, а все остальные останутся висеть. В свою очередь browser.quit() закрывает 
все окна, вкладки, и процессы вебдрайвера, запущенные во время тестовой сессии. 
Подробнее можно посмотреть здесь: Difference between webdriver.Dispose(), .Close() and .Quit(). 
Будьте внимательны с этими методами и, в общем случае, всегда используйте browser.quit(). 

Но что будет, если скрипт не дойдет до выполнения этого финального шага, а упадет с ошибкой где-то раньше? 

Для того чтобы гарантировать закрытие, даже если произошла ошибка в предыдущих строках, 
проще всего использовать конструкцию try/finally: 

from selenium import webdriver
from selenium.webdriver.common.by import By
link = "http://suninjuly.github.io/simple_form_find_task.html"
try:
    browser = webdriver.Chrome()
    browser.get(link)
    button = browser.find_element(By.ID, "submit_button")
    button.click()
finally:
    # закрываем браузер после всех манипуляций
    browser.quit()

Можете попробовать запустить оба примера и обратить внимание на разницу.

Подробно говорить об обработке исключений мы сейчас не будем, здесь важно понимать только то, 
что даже если в коде внутри блока try произойдет какая-то ошибка, то код внутри блока finally 
выполнится в любом случае. Советуем добавлять такую обработку ко всем своим скриптам при 
выполнении задач этого и следующего модулей, а в третьем модуле мы обсудим более лаконичные конструкции.

Если хотите узнать больше про исключения, как их кидать, ловить и как с ними жить, 
то советуем к прохождению вот этот урок:  Ошибки и исключения.
https://stepik.org/lesson/24463/step/1?unit=6771


Поиск всех необходимых элементов с помощью find_elements_by
===============================================================
Мы уже упоминали, что метод find_element_by возвращает только первый из всех элементов, 
которые подходят под условия поиска. Иногда возникает ситуация, когда у нас есть несколько 
одинаковых по сути объектов на странице, например, иконки товаров в корзине интернет-магазина. 
В тесте нам нужно проверить, что отображаются все выбранные для покупки товары. 
Для этого существуют методы find_elements_by, которые в отличие от find_element_by вернут 
список всех найденных элементов по заданному условию. Проверив длину списка, мы можем удостовериться, 
что в корзине отобразилось правильное количество товаров. 
Пример кода (код приведен только для примера, сайта fake-shop.com скорее всего не существует):

# подготовка для теста
# открываем страницу первого товара
# данный сайт не существует, этот код приведен только для примера
browser.get("https://fake-shop.com/book1.html")

# добавляем товар в корзину
add_button = browser.find_element_by_css_selector(".add")
add_button.click()

# открываем страницу второго товара
browser.get("https://fake-shop.com/book2.html")

# добавляем товар в корзину
add_button = browser.find_element_by_css_selector(".add")
add_button.click()

# тестовый сценарий
# открываем корзину
browser.get("https://fake-shop.com/basket.html")

# ищем все добавленные товары
goods = browser.find_elements_by_css_selector(".good")

# проверяем, что количество товаров равно 2
assert len(goods) == 2
Набор стратегий здесь такой же, как и в случае с find_element_by:

find_elements_by_css_selector;
find_elements_by_xpath;
find_elements_by_name;
find_elements_by_tag_name;
find_elements_by_class_name;
find_elements_by_link_text;
find_elements_by_partial_link_text.

Также для поиска нескольких элементов мы можем использовать универсальный метод 
find_elements вместе с атрибутами класса By:

from selenium.webdriver.common.by import By


browser.find_elements(By.CSS_SELECTOR, "button.submit")

!Важно. Обратите внимание на важную разницу в результатах, которые возвращают методы 
find_element и find_elements. Если первый метод не смог найти элемент на странице, 
то он вызовет ошибку NoSuchElementException, которая прервёт выполнение вашего кода. 
Второй же метод всегда возвращает валидный результат: если ничего не было найдено, 
то он вернёт пустой список и ваша программа перейдет к выполнению следующего шага в коде.


Уникальность селекторов: часть 1
======================================
Мы уже упоминали, что идеальный селектор — это такой селектор, 
который позволяет найти только один искомый элемент на странице. 
Благодаря уникальным селекторам наши тесты становятся стабильнее 
и меньше зависят от изменений в вёрстке страницы. Небольшие изменения 
разработчики делают достаточно часто, а мы бы не хотели постоянно исправлять наши тесты.

Другое важное замечание: хороший тест проверяет только маленькую, 
атомарную часть функциональности. Простые тесты, которые проверяют небольшой сценарий, 
лучше, чем один большой тест, проверяющий сразу много сценариев. 
Благодаря простым тестам мы быстрее локализуем место в продукте, где появился баг, 
а также можем найти одновременно несколько новых багов. Упавший большой автотест укажет 
только на первую встреченную проблему, так как он заканчивает работу при первой же 
найденной ошибке. В этом их отличие от ручных тестов, в которых мы, проверяя функциональность 
продукта по тест-кейсу, можем гибко обойти встречающиеся проблемы и пройти тест-кейс до конца, найдя все баги.

Рассмотрим следующий пример: у нас есть форма регистрации, в которой есть обязательные 
и необязательные поля для заполнения. 
Нужно проверить, что можно успешно зарегистрироваться на сайте.

Сценарий плохого автотеста:

1
Открыть страницу с формой
Заполнить все поля
Нажать кнопку "Регистрация"
Проверить, что есть сообщение об успешной регистрации


Лучше разбить предыдущий тест на набор более простых автотестов:

1
Открыть страницу с формой
Заполнить только обязательные поля
Нажать кнопку "Регистрация"
Проверить, что есть сообщение об успешной регистрации

2
Открыть страницу с формой
Заполнить все обязательные поля
Заполнить все необязательные поля
Нажать кнопку "Регистрация"
Проверить, что есть сообщение об успешной регистрации

3
Открыть страницу с формой
Заполнить только необязательные поля
Проверить, что кнопка "Регистрация" неактивна


Уникальность селекторов: часть 2
=======================================
Попробуем реализовать один из автотестов из предыдущего шага. 
Вам дана страница с формой регистрации. 
Проверьте, что можно зарегистрироваться на сайте, заполнив только обязательные поля, 
отмеченные символом *: First name, last name, email. 
Текст для полей может быть любым. Успешность регистрации проверяется сравнением ожидаемого текста 
"Congratulations! You have successfully registered!" с текстом на странице, 
которая открывается после регистрации. Для сравнения воспользуемся стандартной конструкцией assert из языка Python.

Ниже дан шаблон кода, который вам нужно использовать для своего теста. 
Не забывайте, что селекторы должны быть уникальными.

from selenium import webdriver
import time

try: 
    link = "http://suninjuly.github.io/registration1.html"
    browser = webdriver.Chrome()
    browser.get(link)

    # Ваш код, который заполняет обязательные поля
    ...

    # Отправляем заполненную форму
    button = browser.find_element_by_css_selector("button.btn")
    button.click()

    # Проверяем, что смогли зарегистрироваться
    # ждем загрузки страницы
    time.sleep(1)

    # находим элемент, содержащий текст
    welcome_text_elt = browser.find_element_by_tag_name("h1")
    # записываем в переменную welcome_text текст из элемента welcome_text_elt
    welcome_text = welcome_text_elt.text

    # с помощью assert проверяем, что ожидаемый текст совпадает с текстом на странице сайта
    assert "Congratulations! You have successfully registered!" == welcome_text

finally:
    # ожидание чтобы визуально оценить результаты прохождения скрипта
    time.sleep(10)
    # закрываем браузер после всех манипуляций
    browser.quit()

Углубимся немного в использовании конструкции assert из данного примера, 
Если результат проверки "Поздравляем! Вы успешно зарегистрировались!" == welcome_text 
вернет значение False, то далее выполнится код assert False. 
Он бросит исключение AssertionError и номер строки, в которой произошла ошибка. 
Если код написан правильно и работал ранее, то такой результат равносилен тому, 
что наш автотест обнаружил баг в тестируемом веб-приложении. 
Если результат проверки вернет True, то выполнится выражение assert True. 
В этом случае код завершится без ошибок — тест прошел успешно. 
Подробнее про использование assert в коде мы поговорим в третьем модуле этого курса.

В этом задании нет автоматических проверок вашего кода. 
Просто убедитесь, что ваш тест проходит успешно, 
и вы не видите AssertionError в результатах работы вашего кода.

Замечание

В этом примере мы использовали метод time.sleep(1), чтобы дождаться загрузки следующей страницы, 
прежде чем выполнять проверки. Если вы будете запускать код без этого метода, 
ваш код может внезапно упасть, хотя проходил ранее. 
Без использования такой паузы WebDriver может перейти к поиску тега h1 слишком рано, 
когда новая страница еще не загрузилась. В таком случаем будем видеть в терминале ошибку:

NoSuchElementException... Unable to locate element: {"method":"tag name","selector":"h1"}

Метод time.sleep(1) говорит Python подождать 1 секунду, прежде чем выполнять следующую строчку кода. 
Если вы всё равно видите эту ошибку, просто увеличьте количество секунд ожидания.

Проблема со своевременным поиском элемента — одна из самых больших проблем, 
которую приходится решать при разработке автотестов для UI. 
В условиях постоянно изменяющейся скорости сетевого соединения и неравномерности нагрузки на серверы 
скорость загрузки страницы может сильно варьироваться. 
Еще одним фактором, влияющим на стабильность работы тестов, является принцип асинхронности выполнения 
кода JavaScript. На простых страницах вы можете этого и не заметить, но на функционально богатых 
страницах время появления элементов страницы может быть непредсказуемо. Хорошо было бы организовать 
тесты так, чтобы не сложилось ситуации, когда они не проходят по причине нестабильной скорости интернета 
или других причин, которые от нас не зависят.

Решать эту проблему с помощью time.sleep() считается плохой практикой, так как заранее трудно указать 
нужное время ожидания. Если выставить слишком большое время ожидания, то тесты будут идти неоправданно 
долго. В дальнейших уроках мы рассмотрим более красивые и эффективные способы решения этой проблемы, 
а пока будем использовать time.sleep() из-за его простоты и наглядности.


Уникальность селекторов: часть 3
=======================================
В предыдущем примере мы хотели показать, что, выбирая селектор с классом ".second" 
для автотеста для первой формы, вы можете попасть в следующую ситуацию: 
обязательное поле "Last name:" вдруг пропадёт при изменениях в продукте, 
как это произошло во второй версии формы, и данные будут введены во второстепенное 
поле с тем же классом. В этом случае тест пройдёт успешно, и мы не будем знать 
о возникшей проблеме. Уникальный селектор может спасти нас в этой ситуации — тест 
упадёт именно в тот момент, когда не обнаружит нужный элемент на странице.

